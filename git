sudo apt-get install git-all
git config --list		список текущих настроек
    --show-origin		с именами файлов
    --show-origin <key>		узнать из какого файла читается настройка
git config <key>		вывести значение определенной настройки
/etc/gitconfig			глобальные настройки (--system)
~/.gitconfig			пользовательский конфиг
.git/config			конфиг репозитория (--local)
git config --global key value	применить настройки ко всем проектам


справка:
git help <cmd>
git cmd --help
man git-<cmd>
git <cmd> -h


первоначальная настройка:
git config --global user.name ""	имя
git config --global user.email ""	почта
git config --global color.ui true/auto	цветовая схема для терминала но не для перенаправления
git config --global core.editor		редактор по умолчанию
git config --global init.defaultBranch	изменить название ветки по умолчанию при инициализации репо
git config --global core.autocrlf input
git config --global core.safecrlf warn
git config --global core.quotepath off


untracked	любые файлы, не входящие в снимок и не подготовленные к коммиту (неотслеживаемые)
unmodified	файлы, входящие в снимок и не подвергнутые изменениям
modified	файлы, входящие в снимок и измененные
staged		файлы, подготовленные к коммиту (проиндексированные)
commited	файлы в снимке (зафиксированные)

начало
git init			инициализация репо и создание ветки master по умолчанию
git add file[s]			добавить unstaged и modified файлы в staged, либо файл с исправленным конфликтом
git commit -m "message"		коммит с сообщением. Сохраняет снимок в состоянии в момент последнего add
git commit -am "msg"		добавляет modified(но не unstaged) файлы и делает коммит
git clone <url>			копировать существующий репо (создает каталог, инициализирует репо и скачивает данные)
    по сути:
    git init			инициализирует репозиторий
    git remote add		добавляет ссылку на удаленный репо
    git pull, а git pull:
	git fetch		скачивает ветки
	git merge		сливает скачанные ветки с локальными
git clone <url> path		копировать в папку path
git status			определения состояния локального репо
git status -s/--short		сокращенный вывод
    ??				новые неотслеживаемые файлы
    M				модифицированные/слева-индексированные/справа-нет
    A				отслеживаемые

настройка альясов в .gitconfig:
[alias]
  co - checkout
  ci - commit
  st -  status
  br - branch
  hist - log --pretty=format:\"%h %ad | %s%d [%an]\" --graph --date=short
  type - cat-file -t
  dump - cat-file -p

Настройка альясов в .profile:
alias gs='git status '
alias ga='git add '
alias gb='git branch '
alias gc='git commit'
alias gd='git diff'
alias gco='git checkout '
alias gk='gitk --all&'
alias gx='gitx --all'

alias got='git '
alias get='git '

настройка игнорирования
.gitignore			шаблоны игнорируемых файлов
    можно использвать эти же файлы отдельно в подкаталогах
    шаблоны применяются рекурсивно для всего дерева
    для отключения рекурсии поставить / в начале
    для исключения каталога поставить / в конце
    для инвертации шаблона поставить ! в качестве первого символа
    *				0 и более символов
    [abc]			любой символ из abc
    ?				1 символ
    [0-9]			любой символ из диапазона
    a/**			все вложенные каталоги для каталога a
man gitignore			почитать подробнее

git diff			сравнение текущих неиндексированных изменений с последним коммитом
git diff --staged/--cached	сравнение проиндексированных изменений с последним коммитом

git commit -v			добавить информацию о дельте изменений (включить патч в сообщение)

git rm				пометить файл для удаления после коммита (индексация удаления)
git rm -f			удалить файл, который уже был модифицирован и проиндексирован
git rm --cached			удалить файл из индекса, но не из рабочего каталога
git mv				переименование, по сути:
    mv 1 2
    git rm 1
    git add 2


лог коммитов
git log				история коммитов(самый новый - наверху)
    -p/--patch			показывает разницу (патч), внесенный в каждый коммит
    -число			показать последние n коммитов
    --stat			сокращенная статистика изменений для каждого коммита
    --shortstat			ещё более сокращенная статистика (только строка с кол-вом)
    --name-only			список измененных файлов
    --name-status		список добавленных, удаленных и измененных файлов
    --abbrev-commit		показывает только несколько символов хеша
    --relative-date		отображает дату в относительном формате
    --oneline			сокращение для --pretty=oneline --abbrev-commit
    --pretty 			меняет формат вывода
	=oneline		в одну строку на коммит
	=short/full/fuller	от меньших подробностей к большим
	=format			кастомный формат
	    %H			хеш коммита
	    %h			сокр. хеш коммита
	    %T			хеш дерева
	    %t			сокр. хеш дерева
	    %P			хеш родителей
	    %p			сокр. хеш родителей
	    %an			имя автора
	    %ae			почта автора
	    %ad			дата автора (формат --date=option)
	    %ar			относительная дата автора
	    %cn			имя коммитера
	    %ce			почта коммитера
	    %cd			дата коммитера
	    %cr			относительная дата коммитера
	    %s			содержание
    --graph			небольшой граф в текстовом виде с текущей веткой и историей слияний
    --since=			список коммитов после указанной даты
    --until			до указанной даты
    --author			фильтровать по автору
    --grep			фильтровать по шаблону (в сообщении коммитов)
    -S name			показывает коммиты, в которых изменение содержит строку name
    -- path			показывает коммиты, в которых изменен файл по указанному пути - path после пробела!
    --no-merges			не показывает коммиты слияния
    branch --not master		коммиты из branch, которых ещё нет в master

git commit --amend		позволяет изменить последний коммит вместо создания нового

отмена изменений
git reset <HEAD> <file>		исключить из индекса (не удаляет)
git reset <HEAD> <file> --hard	удаляет полнолстью и безвозвратно
git checkout -- <file>		отменить изменения (изменения будут стерты!)
git restore --staged <file>	исключить из индекса (не удаляет)
git restore <file>		отменить изменения

удаленные репозитории
git remote			список удаленных репо
git remote -v			посмотреть адреса для push и fetch, привязанные к репо
git remote add <name> <url>	добавить удаленный репо
git fetch <remote>		получить изменения с удаленного репо, но не сливать с локальной веткой
git pull			получить изменения и слить с локальной веткой
git config --global pull.rebase	настройка метода слияния при пулле
git push <remote> <branch>	отправить локальную ветку в удаленный репо
git remote show <name>		информация об удаленном репо
git remote rename <old> <new>	переименовать удаленный репо
git remote rm/remove <name>	удалить удаленный репо

теги
git tag				просмотр тегов
git tag -l/--list		поиск тегов по шаблону
git tag -a name -m msg		создать аннотированный тег (полноценный объект)
git show тег			данные тега вместе с коммитом
git tag name			создать легковесный тег (простой указатель)
git tag -a name hash		добавить тег к коммиту по хешу
git push <remote> <tagname>	отправить тег на удаленный репо
git push <remote> --tags	отправить все теги
git push <remote> --follow-tags	отправить только аннотированные теги
git tag -d <tagname>		удалить тег локально
git push <remote> :refs/tags/<tagname>	удалить тег из удаленного репо
git push origin --delete <tagname>	аналогично
git checkout <tagname>		получить версии файлов, на которые указывает тег
git checkout -b <branch> <tag>	создать ветку с состоянием, соответствующим тегу

альясы
git config --global alias.name cmd	создать алиас

ветки
bit branch <name>		создать ветку
git branch			список веток (* - где указатель head)
git branch -r			список удаленных веток
HEAD				указатель на ветку
git checkout <name>		переключиться на ветку (переместить указатель head) и обновить локальный каталог
git log <name>			история конкретной ветки
git log <branch1>..<branch2>	показать коммиты, которые есть во второй ветке, но нет в первой
git log --all			история всех веток
git log --graph			нарисовать ветки
git checkout -b <name>		создать ветку и переключиться на неё
git switch <name>		переключить на ветку
git switch -c <name>		создать ветку и переключиться на неё
git switch -			вернуться к предыдущей извлеченной ветке
git merge <name>		выполнить слияние текущей ветки с веткой <name>
git branch -d <name>		удалить ветку
git branch -D <name>		удалить ветку, даже если она содержит не слитые наработки

fast-forward			простое слияние, если в ветке, с которой сливают не было изменений
recursive			чуть сложнее - в ветке, с которой сливают, произошли изменения 
				после создания сливаемой ветки, но они не конфликтуют. Создается коммит слияния
merge conflict			конфликт слияния - в разных ветках меняли одно и то же

git status покажет, какие конфликты не разрешены.
необходимо вручную разрешить конфликт и добавить с помощью git add и git commit.

git mergetool			графический инструмент, который проведет по конфликтам

git branch -v			посмотреть последний коммит в каждой ветке
git branch --merged/--no-merged	слитые/не слитые ветки по отношению к текущей
    то же самое, но с указанием ветки - по отношению к указанной ветке

git branch --move <old> <new>	переименовать ветку локально
git push --set-upstream <remote> <new>	залить переименованную ветку

git branch --all		список всех веток (локальных и удаленных)

git push <remote> --delete <branch>	удалить ветку

git ls-remote <remote>		полный список удаленных ссылок
git remote show <remote>	информация об удаленных ветках
git clone -o name url		спулить репозиторий с указанным именем (вместо origin)
git push <remote> <branch>	отправить локальную ветку в удаленный репо
git checkout -b name rname	создать локальную ветку name из ветки слежения rname
git checkout --track rname	аналогично
git checkout name		аналогично, если есть удаленная ветка с таким же именем
git fetch <remote>		только создаст/обновит ветки слежения
git branch -u rname		настроить текущую локальную ветку для слежения за удаленной веткой rname
git push -u <remote> <branch>	сокращение push --set-upstream
git branch -vv			полный список локальных веток и веток, которые они отслеживают и состояние
git fetch --all			получить данные со всех удаленных репо


git rebase <branch>		перебазирование текущей ветки относительно указанной.
				сначала коммиты из текущей ветки отправляются во временную зону,
				затем применяются коммиты из указанной ветки, затем коммиты из
				временной зоны. после этого можно выполнить fast-forward слияние.
перебазирование не создает коммиты слияния и позволяет сделать fast-forward слияние.
история коммитов будет выглядеть чище.
git rebase --onto master br1 br2	найти в ветке br2 изменения относительно ветки br1 и применить
их к ветке master. после этого можно выполнить слияние ветки master с веткой br2. Делается в случае
если ветка br2 является потомком ветки br1.
git rebase <base> <topic>	тоже, что и git rebase <base>, находясь в ветке topic
git rebase remote/branch	перебазирует сначала коммиты с удаленного репо, затем применит локальные
git pull --rebase		спулить и перебазировать, а не сливать ветки


file:///srv/git/project.git		локальный адрес, с которым гит будет работать как с сетевым
/srv/git/project.git			аналогично, только быстрее чем сетевой адрес
https://github.com/schacon/simplegit	"умный" http
ssh://[user@]server/project.git		ssh - быстро, безопасно, популярно

git clone --bare dir name.git		создать новый пустой репозиторий

git diff --check			вывести список ненужных пробелов

git rebase -i				интерактивный rebase, позволяет изменять сделанные коммиты

git cherry-pick				позволяет выбирать определенные коммиты из ветки

git request-pull			запрос слияния форк-проекта
git request pull <base branch> <fork>	base branch - куда сливать изменения, fork - где они находятся

git merge --squash <branch>		берет все изменения из указанной ветки, объединяет и создает
					новый коммит в текущей ветки без создания коммита слияния

git push -u remote branch		отправить ветку в удаленный репозиторий и сделать её отслеживаемой
git push -u remote local:remote		отправить локальную ветку в удаленную с другим именем

Если изменения в нашем пулл реквесте приводят к конфликтам,
изза того что были применены другие патчи, то нужно попытаться
перебазировать свою ветку нашего форка относительно ориджин/мастер:
git checkout localBranch
git rebase origin/master
git push -f myFork localBranch		-f чтобы переписать историю ветки
затем отправить пулл реквест:
git request-pull origin/master myFork

Если нужно внести изменения в уже принятом пулл реквесте:
git checkout -b localBranch2 origin/master	создаем новую ветку на основе исходной
git merge --squash localBranch			берем все изменения из 1 ветки и в 1 коммите создаем их в текущей
git commit...					коммитим
git pysh myFork localBranch2			отправляем в форк

синхронизация форка в случае изменения основного:
git checkout master			переключаемся на локальный мастер
git pull <uri>				пуллим оригинал
git push origin master			пушим в форк

или можно настроить:
git remote add origin uri				добавляем ссылку на удаленный оригинальный репо
git fetch origin					загружаем оттуда код
git branch --set-upstream-to=origin/master master	настраиваем отслеживание для пула
git config --local remote.pushDefault origin		настраиваем форк для пуша

и затем делать все короче:
git checkout master
git pull
pit push

извлечение удаленных веток:
git remote add remote url		добавляем ссылку на удаленный репо
git fetch remote			загружаем код
git checkout -b localBranch remote/branch	создаем локальную ветку из удаленной

отмена неиндексированных изменений:
git checkout file

отмена индексированных:
git reset file
git checkout file

отмена коммита:
git revert --no-edit	--no-edit чтобы не редактировать сообщение